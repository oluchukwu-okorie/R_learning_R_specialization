---
title: "R programming Basics"
author: "Oluchukwu"
date: "2024-05-24"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Data Types
### R Data Types:Objects
Everything in R is basically an an object
An object has attributes which define the objects(d most basic class,length: e.g of a vector,e.g names,dimensions)
```{r}
chars <- vector("numeric")
chars
attributes(chars)
chars
```
Note note all objects have an attributes.There are other user defined attributes.There is also an attribute function to set attributes to an object
The basic atomic classes of objects in R include:
*Character*
*Numeric(real numbers)*
*Integer*
*Complex*
*Logical(T,F)*
The most basic object is vector which can contain multiple copies of a single type of object.E.g a
An exception to this is the list that can contain different classes of vector including a dataframe

### Creating a vector(an empty vector)
```{r}
d <- vector()
d
attributes(d)
```

### Character
This are string 
```{r}
char <- c("i","j","f")
char
attributes(char)
```
### Numbers in R
Numbers in R are considered numeric in R 
All numbers are treated as numeric double precision real number objects
```{r}
num <- c(1,2,3,4,3.5)
num
class(num)
num_inf <- Inf/0
num_inf# A special number also note there is also -Inf
num_NaN <- 0/0
1/Inf
num_NaN
```
### Integers 
Integers have to be called specifically
```{r}
int <- c(1L,2L,3L,4L)
int
```
###Working with files

|==============================                                      |  44%
| We will do all our work in this new directory and then delete it after we
| are done. This is the R analog to "Take only pictures, leave only
| footprints."

...

  |===============================                                     |  46%
| Set your working directory to "testdir" with the setwd() command.

> setwd("testdir")

| That's correct!

  |=================================                                   |  49%
| In general, you will want your working directory to be someplace sensible,
| perhaps created for the specific project that you are working on. In fact,
| organizing your work in R packages using RStudio is an excellent option.
| Check out RStudio at http://www.rstudio.com/

...

  |===================================                                 |  51%
| Create a file in your working directory called "mytest.R" using the
| file.create() function.

> file.create("mytestR")
[1] TRUE

| Try again. Getting it right on the first try is boring anyway! Or, type
| info() for more options.

| file.create("mytest.R") will get the job done!

> file.create("mytest.R")
[1] TRUE

| You are really on a roll!

  |=====================================                               |  54%
| This should be the only file in this newly created directory. Let's check
| this by listing all the files in the current directory.

> ls()
 [1] "a"       "chars"   "d"       "my_div"  "my_sqrt" "num"     "num_inf"
 [8] "num_NaN" "num_NAN" "old.dir" "x"       "y"       "z"      

| You almost had it, but not quite. Try again. Or, type info() for more
| options.

| list.files() shows that the directory only contains mytest.R.

> list.files()
[1] "mytest.R" "mytestR" 

| Excellent job!

  |======================================                              |  56%
| Check to see if "mytest.R" exists in the working directory using the
| file.exists() function.

> file.exists("mytest.R")
[1] TRUE

| Keep working like that and you'll get there!

  |========================================                            |  59%
| These sorts of functions are excessive for interactive use. But, if you are
| running a program that loops through a series of files and does some
| processing on each one, you will want to check to see that each exists
| before you try to process it.

...

  |==========================================                          |  62%
| Access information about the file "mytest.R" by using file.info().

> file.info("mytest.R")
         size isdir mode               mtime               ctime
mytest.R    0 FALSE  666 2024-05-24 19:39:44 2024-05-24 19:39:44
                       atime exe
mytest.R 2024-05-24 19:39:44  no

| Your dedication is inspiring!

  |============================================                        |  64%
| You can use the $ operator --- e.g., file.info("mytest.R")$mode --- to grab
| specific items.

...

  |=============================================                       |  67%
| Change the name of the file "mytest.R" to "mytest2.R" by using
| file.rename().

> file.rename("mytest.R","mytest2.R")
[1] TRUE

| Nice work!

  |===============================================                     |  69%
| Your operating system will provide simpler tools for these sorts of tasks,
| but having the ability to manipulate files programatically is useful. You
| might now try to delete mytest.R using file.remove('mytest.R'), but that
| won't work since mytest.R no longer exists. You have already renamed it.

...

  |=================================================                   |  72%
| Make a copy of "mytest2.R" called "mytest3.R" using file.copy().

> file.copy("mytest2.R","mytest3.R")
[1] TRUE

| You got it right!

  |===================================================                 |  74%
| You now have two files in the current directory. That may not seem very
| interesting. But what if you were working with dozens, or millions, of
| individual files? In that case, being able to programatically act on many
| files would be absolutely necessary. Don't forget that you can,
| temporarily, leave the lesson by typing play() and then return by typing
| nxt().

...

  |====================================================                |  77%
| Provide the relative path to the file "mytest3.R" by using file.path().

> file.path("mytest3.R")
[1] "mytest3.R"

| You are amazing!

  |======================================================              |  79%
| You can use file.path to construct file and directory paths that are
| independent of the operating system your R code is running on. Pass
| 'folder1' and 'folder2' as arguments to file.path to make a
| platform-independent pathname.

> file.path('folder1')
[1] "folder1"

| Keep trying! Or, type info() for more options.

| file.path("folder1", "folder2") works.

> file.path(folder1,folder2)
Error: object 'folder1' not found
> info()

| When you are at the R prompt (>):
| -- Typing skip() allows you to skip the current question.
| -- Typing play() lets you experiment with R on your own; swirl will ignore
| what you do...
| -- UNTIL you type nxt() which will regain swirl's attention.
| -- Typing bye() causes swirl to exit. Your progress will be saved.
| -- Typing main() returns you to swirl's main menu.
| -- Typing info() displays these options again.

> file.path('folder1','folder2')
[1] "folder1/folder2"

| That's a job well done!

  |========================================================            |  82%
| Take a look at the documentation for dir.create by entering ?dir.create .
| Notice the 'recursive' argument. In order to create nested directories,
| 'recursive' must be set to TRUE.

> ?dir.create

| You nailed it! Good job!

  |==========================================================          |  85%
| Create a directory in the current working directory called "testdir2" and a
| subdirectory for it called "testdir3", all in one command by using
| dir.create() and file.path().

> dir.create("testdir2",file.path("testdir3"))

| Give it another try. Or, type info() for more options.

| dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE) will do the
| trick. If you forgot the recursive argument, the command may have appeared
| to work, but it didn't create the nested directory.

> dir.create(file.path('testdir2','testdir3'))

| Not quite, but you're learning! Try again. Or, type info() for more
| options.

| dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE) will do the
| trick. If you forgot the recursive argument, the command may have appeared
| to work, but it didn't create the nested directory.

> dir.create(file.path('testdir2','testdir3'),recursive=TRUE)
Warning message:
In dir.create(file.path("testdir2", "testdir3"), recursive = TRUE) :
  'testdir2\testdir3' already exists

| Excellent work!

  |===========================================================         |  87%
| Go back to your original working directory using setwd(). (Recall that we
| created the variable old.dir with the full path for the orginal working
| directory at the start of these questions.)

> setwd()
Error in setwd() : argument "dir" is missing, with no default
> setwd(old.dir)

| That's a job well done!

  |=============================================================       |  90%
| It is often helpful to save the settings that you had before you began an
| analysis and then go back to them at the end. This trick is often used
| within functions; you save, say, the par() settings that you started with,
| mess around a bunch, and then set them back to the original values at the
| end. This isn't the same as what we have done here, but it seems similar
| enough to mention.

...

  |===============================================================     |  92%
| After you finish this lesson delete the 'testdir' directory that you just
| left (and everything in it)

...

  |=================================================================   |  95%
| Take nothing but results. Leave nothing but assumptions. That sounds like
| 'Take nothing but pictures. Leave nothing but footprints.' But it makes no
| sense! Surely our readers can come up with a better motto . . .

...

  |==================================================================  |  97%
| In this lesson, you learned how to examine your R workspace and work with
| the file system of your machine from within R. Thanks for playing!

...

  |====================================================================| 100%
  
###Sequence of Numbers
| In this lesson, you'll learn how to create sequences of numbers in R.

...

  |===                                                                 |   4%
| The simplest way to create a sequence of numbers in R is by using the `:`
| operator. Type 1:20 to see how it works.

> 1:20
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| That's the answer I was looking for.

  |======                                                              |   9%
| That gave us every integer between (and including) 1 and 20. We could also
| use it to create a sequence of real numbers. For example, try pi:10.

> pi:10
[1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593

| Keep up the great work!

  |=========                                                           |  13%
| The result is a vector of real numbers starting with pi (3.142...) and
| increasing in increments of 1. The upper limit of 10 is never reached,
| since the next number in our sequence would be greater than 10.

...

  |============                                                        |  17%
| What happens if we do 15:1? Give it a try to find out.

> 15:1
 [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1

| You're the best!

  |===============                                                     |  22%
| It counted backwards in increments of 1! It's unlikely we'd want this
| behavior, but nonetheless it's good to know how it could happen.

...

  |==================                                                  |  26%
| Remember that if you have questions about a particular R function, you can
| access its documentation with a question mark followed by the function
| name: ?function_name_here. However, in the case of an operator like the
| colon used above, you must enclose the symbol in backticks like this: ?`:`.
| (NOTE: The backtick (`) key is generally located in the top left corner of
| a keyboard, above the Tab key. If you don't have a backtick key, you can
| use regular quotes.)

...?`:`

  |=====================                                               |  30%
| Pull up the documentation for `:` now.

> ?`:`

| Great job!

  |========================                                            |  35%
| Often, we'll desire more control over a sequence we're creating than what
| the `:` operator gives us. The seq() function serves this purpose.

...

  |===========================                                         |  39%
| The most basic use of seq() does exactly the same thing as the `:`
| operator. Try seq(1, 20) to see this.

> seq(1,20)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| You're the best!

  |==============================                                      |  43%
| This gives us the same output as 1:20. However, let's say that instead we
| want a vector of numbers ranging from 0 to 10, incremented by 0.5. seq(0,
| 10, by=0.5) does just that. Try it out.

> seq(0,10,by=0.5)
 [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5
[15]  7.0  7.5  8.0  8.5  9.0  9.5 10.0

| All that hard work is paying off!

  |=================================                                   |  48%
| Or maybe we don't care what the increment is and we just want a sequence of
| 30 numbers between 5 and 10. seq(5, 10, length=30) does the trick. Give it
| a shot now and store the result in a new variable called my_seq.

> seq(5,10,length=30)
 [1]  5.000000  5.172414  5.344828  5.517241  5.689655  5.862069  6.034483
 [8]  6.206897  6.379310  6.551724  6.724138  6.896552  7.068966  7.241379
[15]  7.413793  7.586207  7.758621  7.931034  8.103448  8.275862  8.448276
[22]  8.620690  8.793103  8.965517  9.137931  9.310345  9.482759  9.655172
[29]  9.827586 10.000000

| You're close...I can feel it! Try it again. Or, type info() for more
| options.

| You're using the same function here, but changing its arguments for
| different results. Be sure to store the result in a new variable called
| my_seq, like this: my_seq <- seq(5, 10, length=30).

> my_seq <- seq(5,10,length=30)

| You are quite good my friend!

  |===================================                                 |  52%
| To confirm that my_seq has length 30, we can use the length() function. Try
| it now.

> length(my_seq)
[1] 30

| Great job!

  |======================================                              |  57%
| Let's pretend we don't know the length of my_seq, but we want to generate a
| sequence of integers from 1 to N, where N represents the length of the
| my_seq vector. In other words, we want a new vector (1, 2, 3, ...) that is
| the same length as my_seq.

...

  |=========================================                           |  61%
| There are several ways we could do this. One possibility is to combine the
| `:` operator and the length() function like this: 1:length(my_seq). Give
| that a try.

> 1:length(my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
[25] 25 26 27 28 29 30

| Nice work!

  |============================================                        |  65%
| Another option is to use seq(along.with = my_seq). Give that a try.

> seq(along.with = my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
[25] 25 26 27 28 29 30

| Keep working like that and you'll get there!

  |===============================================                     |  70%
| However, as is the case with many common tasks, R has a separate built-in
| function for this purpose called seq_along(). Type seq_along(my_seq) to see
| it in action.

> seq_along(my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
[25] 25 26 27 28 29 30

| All that practice is paying off!

  |==================================================                  |  74%
| There are often several approaches to solving the same problem,
| particularly in R. Simple approaches that involve less typing are generally
| best. It's also important for your code to be readable, so that you and
| others can figure out what's going on without too much hassle.

...

  |=====================================================               |  78%
| If R has a built-in function for a particular task, it's likely that
| function is highly optimized for that purpose and is your best option. As
| you become a more advanced R programmer, you'll design your own functions
| to perform tasks when there are no better options. We'll explore writing
| your own functions in future lessons.

...

  |========================================================            |  83%
| One more function related to creating sequences of numbers is rep(), which
| stands for 'replicate'. Let's look at a few uses.

...

  |===========================================================         |  87%
| If we're interested in creating a vector that contains 40 zeros, we can use
| rep(0, times = 40). Try it out.

> rep(0.times = 40)
Error: unexpected symbol in "rep(0.times"
> rep(0,times=40)
 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[38] 0 0 0

| Excellent work!

  |==============================================================      |  91%
| If instead we want our vector to contain 10 repetitions of the vector (0,
| 1, 2), we can do rep(c(0, 1, 2), times = 10). Go ahead.

> rep(c(o,1,2))
Error: object 'o' not found
> rep(C(0,1,2))
Error in `contrasts<-`(`*tmp*`, how.many, value = contr) : 
  contrasts can be applied only to factors with 2 or more levels
> rep(c(0,1,2),times =10)
 [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2

| Nice work!

  |=================================================================   |  96%
| Finally, let's say that rather than repeating the vector (0, 1, 2) over and
| over again, we want our vector to contain 10 zeros, then 10 ones, then 10
| twos. We can do this with the `each` argument. Try rep(c(0, 1, 2), each =
| 10).

> rep(c(0,1,2),each =10)
 [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2

| Excellent work!

  |====================================================================| 100%
##### Vectors
|                                                                    |   0%

| The simplest and most common data structure in R is the vector.

...

  |==                                                                  |   3%
| Vectors come in two different flavors: atomic vectors and lists. An atomic
| vector contains exactly one data type, whereas a list may contain multiple
| data types. We'll explore atomic vectors further before we get to lists.

...

  |====                                                                |   5%
| In previous lessons, we dealt entirely with numeric vectors, which are one
| type of atomic vector. Other types of atomic vectors include logical,
| character, integer, and complex. In this lesson, we'll take a closer look
| at logical and character vectors.

...

  |=====                                                               |   8%
| Logical vectors can contain the values TRUE, FALSE, and NA (for 'not
| available'). These values are generated as the result of logical
| 'conditions'. Let's experiment with some simple conditions.

...

  |=======                                                             |  11%
| First, create a numeric vector num_vect that contains the values 0.5, 55,
| -10, and 6.

> num_vect <- c(0.5,55,-10,6)

| You are doing so well!

  |=========                                                           |  13%
| Now, create a variable called tf that gets the result of num_vect < 1,
| which is read as 'num_vect is less than 1'.

> tf <- num_vect < 1

| Keep up the great work!

  |===========                                                         |  16%
| What do you think tf will look like?

1: a single logical value
2: a vector of 4 logical values

Selection: 2

| You nailed it! Good job!

  |=============                                                       |  18%
| Print the contents of tf now.

> tf
[1]  TRUE FALSE  TRUE FALSE

| All that practice is paying off!

  |==============                                                      |  21%
| The statement num_vect < 1 is a condition and tf tells us whether each
| corresponding element of our numeric vector num_vect satisfies this
| condition.

...

  |================                                                    |  24%
| The first element of num_vect is 0.5, which is less than 1 and therefore
| the statement 0.5 < 1 is TRUE. The second element of num_vect is 55, which
| is greater than 1, so the statement 55 < 1 is FALSE. The same logic applies
| for the third and fourth elements.

...

  |==================                                                  |  26%
| Let's try another. Type num_vect >= 6 without assigning the result to a new
| variable.

> num_vect >=6
[1] FALSE  TRUE FALSE  TRUE

| All that hard work is paying off!

  |====================                                                |  29%
| This time, we are asking whether each individual element of num_vect is
| greater than OR equal to 6. Since only 55 and 6 are greater than or equal
| to 6, the second and fourth elements of the result are TRUE and the first
| and third elements are FALSE.

...

  |=====================                                               |  32%
| The `<` and `>=` symbols in these examples are called 'logical operators'.
| Other logical operators include `>`, `<=`, `==` for exact equality, and
| `!=` for inequality.

...

  |=======================                                             |  34%
| If we have two logical expressions, A and B, we can ask whether at least
| one is TRUE with A | B (logical 'or' a.k.a. 'union') or whether they are
| both TRUE with A & B (logical 'and' a.k.a. 'intersection'). Lastly, !A is
| the negation of A and is TRUE when A is FALSE and vice versa.

...

  |=========================                                           |  37%
| It's a good idea to spend some time playing around with various
| combinations of these logical operators until you get comfortable with
| their use. We'll do a few examples here to get you started.

...

  |===========================                                         |  39%
| Try your best to predict the result of each of the following statements.
| You can use pencil and paper to work them out if it's helpful. If you get
| stuck, just guess and you've got a 50% chance of getting the right answer!

...

  |=============================                                       |  42%
| (3 > 5) & (4 == 4)

1: TRUE
2: FALSE

Selection: 2

| You got it right!

  |==============================                                      |  45%
| (TRUE == TRUE) | (TRUE == FALSE)

1: TRUE
2: FALSE

Selection: 1

| That's correct!

  |================================                                    |  47%
| ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)

1: TRUE
2: FALSE

Selection: 1

| That's the answer I was looking for.

  |==================================                                  |  50%
| Don't worry if you found these to be tricky. They're supposed to be.
| Working with logical statements in R takes practice, but your efforts will
| be rewarded in future lessons (e.g. subsetting and control structures).

...

  |====================================                                |  53%
| Character vectors are also very common in R. Double quotes are used to
| distinguish character objects, as in the following example.

...

  |======================================                              |  55%
| Create a character vector that contains the following words: "My", "name",
| "is". Remember to enclose each word in its own set of double quotes, so
| that R knows they are character strings. Store the vector in a variable
| called my_char.

> my_char <- c("My","name","is")

| Keep working like that and you'll get there!

  |=======================================                             |  58%
| Print the contents of my_char to see what it looks like.

> my_char
[1] "My"   "name" "is"  

| Perseverance, that's the answer.

  |=========================================                           |  61%
| Right now, my_char is a character vector of length 3. Let's say we want to
| join the elements of my_char together into one continuous character string
| (i.e. a character vector of length 1). We can do this using the paste()
| function.

...

  |===========================================                         |  63%
| Type paste(my_char, collapse = " ") now. Make sure there's a space between
| the double quotes in the `collapse` argument. You'll see why in a second.

> paste(my_char,collapse="")
[1] "Mynameis"

| That's not exactly what I'm looking for. Try again. Or, type info() for
| more options.

| Use paste(my_char, collapse = " ") to collapse the words in the vector so
| they almost form a sentence. There should be a single space between the
| double quotes in the `collapse` argument so that there are single spaces
| separating the words.

> paste(my_char,collapse =" ")
[1] "My name is"

| Your dedication is inspiring!

  |=============================================                       |  66%
| The `collapse` argument to the paste() function tells R that when we join
| together the elements of the my_char character vector, we'd like to
| separate them with single spaces.

...

  |===============================================                     |  68%
| It seems that we're missing something.... Ah, yes! Your name!

...

  |================================================                    |  71%
| To add (or 'concatenate') your name to the end of my_char, use the c()
| function like this: c(my_char, "your_name_here"). Place your name in double
| quotes where I've put "your_name_here". Try it now, storing the result in a
| new variable called my_name.

> c(my_char, "your_name_here")
[1] "My"             "name"           "is"             "your_name_here"

| That's not exactly what I'm looking for. Try again. Or, type info() for
| more options.

| Tack your name on to the end of the my_char vector using the c() function.
| Be sure to assign the result to a new variable called my_name. If your name
| was "Swirl", you would type my_name <- c(my_char, "Swirl").

> my_name <- c(my_char,"Oluchukwu")

| You nailed it! Good job!

  |==================================================                  |  74%
| Take a look at the contents of my_name.

> my_name
[1] "My"        "name"      "is"        "Oluchukwu"

| Keep up the great work!

  |====================================================                |  76%
| Now, use the paste() function once more to join the words in my_name
| together into a single character string. Don't forget to say collapse = "
| "!

> paste(my_name ,collapse = " ")
[1] "My name is Oluchukwu"

| That's correct!

  |======================================================              |  79%
| In this example, we used the paste() function to collapse the elements of a
| single character vector. paste() can also be used to join the elements of
| multiple character vectors.

...

  |=======================================================             |  82%
| In the simplest case, we can join two character vectors that are each of
| length 1 (i.e. join two words). Try paste("Hello", "world!", sep = " "),
| where the `sep` argument tells R that we want to separate the joined
| elements with a single space.

> paste("Hello","world!",sep = " ")
[1] "Hello world!"

| That's correct!

  |=========================================================           |  84%
| For a slightly more complicated example, we can join two vectors, each of
| length 3. Use paste() to join the integer vector 1:3 with the character
| vector c("X", "Y", "Z"). This time, use sep = "" to leave no space between
| the joined elements.

> paste (1:3,c("X","Y","Z"),sep = "")
[1] "1X" "2Y" "3Z"

| You are doing so well!

  |===========================================================         |  87%
| What do you think will happen if our vectors are of different length?
| (Hint: we talked about this in a previous lesson.)

...

  |=============================================================       |  89%
| Vector recycling! Try paste(LETTERS, 1:4, sep = "-"), where LETTERS is a
| predefined variable in R containing a character vector of all 26 letters in
| the English alphabet.

> paste(LETTERS,1:4,sep = "-")
 [1] "A-1" "B-2" "C-3" "D-4" "E-1" "F-2" "G-3" "H-4" "I-1" "J-2" "K-3" "L-4"
[13] "M-1" "N-2" "O-3" "P-4" "Q-1" "R-2" "S-3" "T-4" "U-1" "V-2" "W-3" "X-4"
[25] "Y-1" "Z-2"

| Keep up the great work!

  |===============================================================     |  92%
| Since the character vector LETTERS is longer than the numeric vector 1:4, R
| simply recycles, or repeats, 1:4 until it matches the length of LETTERS.

...

  |================================================================    |  95%
| Also worth noting is that the numeric vector 1:4 gets 'coerced' into a
| character vector by the paste() function.

...

  |==================================================================  |  97%
| We'll discuss coercion in another lesson, but all it really means is that
| the numbers 1, 2, 3, and 4 in the output above are no longer numbers to R,
| but rather characters "1", "2", "3", and "4".

...

  |====================================================================| 100%
  
###Missing Values
  |                                                                    |   0%

| Missing values play an important role in statistics and data analysis.
| Often, missing values must not be ignored, but rather they should be
| carefully studied to see if there's an underlying pattern or cause for
| their missingness.

...

  |===                                                                 |   5%
| In R, NA is used to represent any value that is 'not available' or
| 'missing' (in the statistical sense). In this lesson, we'll explore missing
| values further.

...

  |=======                                                             |  10%
| Any operation involving NA generally yields NA as the result. To
| illustrate, let's create a vector c(44, NA, 5, NA) and assign it to a
| variable x.

> x <- c(44,NA,5,NA)

| You are amazing!

  |==========                                                          |  15%
| Now, let's multiply x by 3.

> x*3
[1] 132  NA  15  NA

| Your dedication is inspiring!

  |==============                                                      |  20%
| Notice that the elements of the resulting vector that correspond with the
| NA values in x are also NA.

...

  |=================                                                   |  25%
| To make things a little more interesting, lets create a vector containing
| 1000 draws from a standard normal distribution with y <- rnorm(1000).

> y <- rnorm(1000)

| Excellent job!

  |====================                                                |  30%
| Next, let's create a vector containing 1000 NAs with z <- rep(NA, 1000).

> z <- rep(NA,1000)

| You are really on a roll!

  |========================                                            |  35%
| Finally, let's select 100 elements at random from these 2000 values
| (combining y and z) such that we don't know how many NAs we'll wind up with
| or what positions they'll occupy in our final vector -- my_data <-
| sample(c(y, z), 100).

> my_data <- sample(c(y,z),100)

| You are really on a roll!

  |===========================                                         |  40%
| Let's first ask the question of where our NAs are located in our data. The
| is.na() function tells us whether each element of a vector is NA. Call
| is.na() on my_data and assign the result to my_na.

> is.na(my_data)
  [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE
 [13]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE
 [25]  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE
 [37]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
 [49] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE
 [61] FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
 [73] FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE
 [85]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE
 [97] FALSE  TRUE  TRUE FALSE

| One more time. You can do it! Or, type info() for more options.

| Assign the result of is.na(my_data) to the variable my_na.

> my_na <- is.na(my_data)

| Excellent work!

  |===============================                                     |  45%
| Now, print my_na to see what you came up with.

> my_na
  [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE
 [13]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE
 [25]  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE
 [37]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
 [49] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE
 [61] FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
 [73] FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE
 [85]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE
 [97] FALSE  TRUE  TRUE FALSE

| All that hard work is paying off!

  |==================================                                  |  50%
| Everywhere you see a TRUE, you know the corresponding element of my_data is
| NA. Likewise, everywhere you see a FALSE, you know the corresponding
| element of my_data is one of our random draws from the standard normal
| distribution.

...

  |=====================================                               |  55%
| In our previous discussion of logical operators, we introduced the `==`
| operator as a method of testing for equality between two objects. So, you
| might think the expression my_data == NA yields the same results as
| is.na(). Give it a try.

> my_data ==NA
  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [25] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [49] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [73] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [97] NA NA NA NA

| Excellent work!

  |=========================================                           |  60%
| The reason you got a vector of all NAs is that NA is not really a value,
| but just a placeholder for a quantity that is not available. Therefore the
| logical expression is incomplete and R has no choice but to return a vector
| of the same length as my_data that contains all NAs.

...

  |============================================                        |  65%
| Don't worry if that's a little confusing. The key takeaway is to be
| cautious when using logical expressions anytime NAs might creep in, since a
| single NA value can derail the entire thing.

...

  |================================================                    |  70%
| So, back to the task at hand. Now that we have a vector, my_na, that has a
| TRUE for every NA and FALSE for every numeric value, we can compute the
| total number of NAs in our data.

...

  |===================================================                 |  75%
| The trick is to recognize that underneath the surface, R represents TRUE as
| the number 1 and FALSE as the number 0. Therefore, if we take the sum of a
| bunch of TRUEs and FALSEs, we get the total number of TRUEs.

...

  |======================================================              |  80%
| Let's give that a try here. Call the sum() function on my_na to count the
| total number of TRUEs in my_na, and thus the total number of NAs in
| my_data. Don't assign the result to a new variable.

> sum(my_na)
[1] 49

| You got it right!

  |==========================================================          |  85%
| Pretty cool, huh? Finally, let's take a look at the data to convince
| ourselves that everything 'adds up'. Print my_data to the console.

> print(my_data)
  [1]          NA  0.40961471  0.40849571  0.35957132          NA          NA
  [7]  0.47243717          NA -0.56514480          NA  0.19203673 -1.04281224
 [13]          NA  1.43591329          NA          NA          NA          NA
 [19]          NA          NA -0.95777950          NA -0.36290178  0.36786218
 [25]          NA  0.02254512  0.10511274 -1.73991234  0.96034573          NA
 [31]          NA  1.39640642  1.92564190          NA  0.64957114          NA
 [37]          NA  0.22829378  0.45762533  0.19811019  1.25659775          NA
 [43]  0.93793717  0.43958133          NA          NA          NA          NA
 [49]  0.01865626          NA  0.42981578          NA -0.07546301          NA
 [55] -0.83954694          NA  0.57498637 -0.30593892          NA          NA
 [61] -1.40241803          NA          NA  0.08697067          NA  1.13746510
 [67] -1.24592116 -1.09270357  0.19777472 -1.33828545 -1.01736761          NA
 [73]  0.63442793  1.24959126          NA  1.20862591 -2.07345504          NA
 [79]          NA          NA  0.29433388          NA  0.45225599  1.01550929
 [85]          NA -0.34699471          NA          NA          NA          NA
 [91] -0.40931935 -0.23063833          NA          NA          NA -0.91604424
 [97]  0.20449608          NA          NA  0.13326605

| Not quite, but you're learning! Try again. Or, type info() for more
| options.

| Print my_data to the console.

> my_data
  [1]          NA  0.40961471  0.40849571  0.35957132          NA          NA
  [7]  0.47243717          NA -0.56514480          NA  0.19203673 -1.04281224
 [13]          NA  1.43591329          NA          NA          NA          NA
 [19]          NA          NA -0.95777950          NA -0.36290178  0.36786218
 [25]          NA  0.02254512  0.10511274 -1.73991234  0.96034573          NA
 [31]          NA  1.39640642  1.92564190          NA  0.64957114          NA
 [37]          NA  0.22829378  0.45762533  0.19811019  1.25659775          NA
 [43]  0.93793717  0.43958133          NA          NA          NA          NA
 [49]  0.01865626          NA  0.42981578          NA -0.07546301          NA
 [55] -0.83954694          NA  0.57498637 -0.30593892          NA          NA
 [61] -1.40241803          NA          NA  0.08697067          NA  1.13746510
 [67] -1.24592116 -1.09270357  0.19777472 -1.33828545 -1.01736761          NA
 [73]  0.63442793  1.24959126          NA  1.20862591 -2.07345504          NA
 [79]          NA          NA  0.29433388          NA  0.45225599  1.01550929
 [85]          NA -0.34699471          NA          NA          NA          NA
 [91] -0.40931935 -0.23063833          NA          NA          NA -0.91604424
 [97]  0.20449608          NA          NA  0.13326605

| You're the best!

  |=============================================================       |  90%
| Now that we've got NAs down pat, let's look at a second type of missing
| value -- NaN, which stands for 'not a number'. To generate NaN, try
| dividing (using a forward slash) 0 by 0 now.

> 0/0
[1] NaN

| You are really on a roll!

  |=================================================================   |  95%
| Let's do one more, just for fun. In R, Inf stands for infinity. What
| happens if you subtract Inf from Inf?

> Inf - inf
Error: object 'inf' not found
> Inf-Inf
[1] NaN

| You got it!

  |====================================================================| 100
  
### Subsetting Vectors
 |                                                                    |   0%
 # Set seed for reproducibility
set.seed(123)


numbers <- rnorm(20)# Generate 20 numbers from a standard normal #distribution
nas <- rep(NA, 20)# Create a vector of 20 NAs
combined <- c(numbers, nas) #Combine the numbers and NAs into a single #vector

x <- sample(combined)# Randomly shuffle the combined vector


| In this lesson, we'll see how to extract elements from a vector based on
| some conditions that we specify.

...

  |==                                                                  |   3%
| For example, we may only be interested in the first 20 elements of a
| vector, or only the elements that are not NA, or only those that are
| positive or correspond to a specific variable of interest. By the end of
| this lesson, you'll know how to handle each of these scenarios.

...

  |===                                                                 |   5%
| I've created for you a vector called x that contains a random ordering of
| 20 numbers (from a standard normal distribution) and 20 NAs. Type x now to
| see what it looks like.

> x
 [1] -0.89929489          NA          NA  1.87472688          NA          NA
 [7]          NA          NA -0.57748558 -0.01980143          NA          NA
[13]          NA  0.61154512          NA          NA  1.20417501  0.49618068
[19]          NA          NA  1.43908695          NA  1.08649762 -0.11123075
[25]          NA  0.24743715 -0.53401567 -0.24031605          NA  2.07876039
[31] -0.51610509  0.16541380  0.47121463          NA  0.28534851          NA
[37]          NA  0.18497411  0.23423906          NA

| Nice work!

  |=====                                                               |   8%
| The way you tell R that you want to select some particular elements (i.e. a
| 'subset') from a vector is by placing an 'index vector' in square brackets
| immediately following the name of the vector.

...

  |=======                                                             |  10%
| For a simple example, try x[1:10] to view the first ten elements of x.

> x[1:10]
 [1] -0.89929489          NA          NA  1.87472688          NA          NA
 [7]          NA          NA -0.57748558 -0.01980143

| Nice work!

  |=========                                                           |  13%
| Index vectors come in four different flavors -- logical vectors, vectors of
| positive integers, vectors of negative integers, and vectors of character
| strings -- each of which we'll cover in this lesson.

...

  |==========                                                          |  15%
| Let's start by indexing with logical vectors. One common scenario when
| working with real-world data is that we want to extract all elements of a
| vector that are not NA (i.e. missing data). Recall that is.na(x) yields a
| vector of logical values the same length as x, with TRUEs corresponding to
| NA values in x and FALSEs corresponding to non-NA values in x.

...

  |============                                                        |  18%
| What do you think x[is.na(x)] will give you?

1: A vector of all NAs
2: A vector of length 0
3: A vector with no NAs
4: A vector of TRUEs and FALSEs

Selection: 1

| Excellent work!

  |==============                                                      |  21%
| Prove it to yourself by typing x[is.na(x)].

> x[is.na(x)]
 [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| You got it right!

  |================                                                    |  23%
| Recall that `!` gives us the negation of a logical expression, so !is.na(x)
| can be read as 'is not NA'. Therefore, if we want to create a vector called
| y that contains all of the non-NA values from x, we can use y <-
| x[!is.na(x)]. Give it a try.

> y <- [!is.na(x)]
Error: unexpected '[' in "y <- ["
> y <- x[!is.na(x)]

| You are really on a roll!

  |=================                                                   |  26%
| Print y to the console.

> y
 [1] -0.89929489  1.87472688 -0.57748558 -0.01980143  0.61154512  1.20417501
 [7]  0.49618068  1.43908695  1.08649762 -0.11123075  0.24743715 -0.53401567
[13] -0.24031605  2.07876039 -0.51610509  0.16541380  0.47121463  0.28534851
[19]  0.18497411  0.23423906

| You are really on a roll!

  |===================                                                 |  28%
| Now that we've isolated the non-missing values of x and put them in y, we
| can subset y as we please.

...

  |=====================                                               |  31%
| Recall that the expression y > 0 will give us a vector of logical values
| the same length as y, with TRUEs corresponding to values of y that are
| greater than zero and FALSEs corresponding to values of y that are less
| than or equal to zero. What do you think y[y > 0] will give you?

1: A vector of all the positive elements of y
2: A vector of all NAs
3: A vector of all the negative elements of y
4: A vector of TRUEs and FALSEs
5: A vector of length 0

Selection: 1

| You are doing so well!

  |=======================                                             |  33%
| Type y[y > 0] to see that we get all of the positive elements of y, which
| are also the positive elements of our original vector x.

> y[y > 0]
 [1] 1.8747269 0.6115451 1.2041750 0.4961807 1.4390869 1.0864976 0.2474371
 [8] 2.0787604 0.1654138 0.4712146 0.2853485 0.1849741 0.2342391

| You are quite good my friend!

  |========================                                            |  36%
| You might wonder why we didn't just start with x[x > 0] to isolate the
| positive elements of x. Try that now to see why.

> x[x > 0]
 [1]        NA        NA 1.8747269        NA        NA        NA        NA
 [8]        NA        NA        NA 0.6115451        NA        NA 1.2041750
[15] 0.4961807        NA        NA 1.4390869        NA 1.0864976        NA
[22] 0.2474371        NA 2.0787604 0.1654138 0.4712146        NA 0.2853485
[29]        NA        NA 0.1849741 0.2342391        NA

| Excellent job!

  |==========================                                          |  38%
| Since NA is not a value, but rather a placeholder for an unknown quantity,
| the expression NA > 0 evaluates to NA. Hence we get a bunch of NAs mixed in
| with our positive numbers when we do this.

...

  |============================                                        |  41%
| Combining our knowledge of logical operators with our new knowledge of
| subsetting, we could do this -- x[!is.na(x) & x > 0]. Try it out.

> x[!is.na(x) & x > 0]
 [1] 1.8747269 0.6115451 1.2041750 0.4961807 1.4390869 1.0864976 0.2474371
 [8] 2.0787604 0.1654138 0.4712146 0.2853485 0.1849741 0.2342391

| You are amazing!

  |==============================                                      |  44%
| In this case, we request only values of x that are both non-missing AND
| greater than zero.

...

  |===============================                                     |  46%
| I've already shown you how to subset just the first ten values of x using
| x[1:10]. In this case, we're providing a vector of positive integers inside
| of the square brackets, which tells R to return only the elements of x
| numbered 1 through 10.

...

  |=================================                                   |  49%
| Many programming languages use what's called 'zero-based indexing', which
| means that the first element of a vector is considered element 0. R uses
| 'one-based indexing', which (you guessed it!) means the first element of a
| vector is considered element 1.

...

  |===================================                                 |  51%
| Can you figure out how we'd subset the 3rd, 5th, and 7th elements of x?
| Hint -- Use the c() function to specify the element numbers as a numeric
| vector.

> x[c(3,5,7)]
[1] NA NA NA

| That's correct!

  |=====================================                               |  54%
| It's important that when using integer vectors to subset our vector x, we
| stick with the set of indexes {1, 2, ..., 40} since x only has 40 elements.
| What happens if we ask for the zeroth element of x (i.e. x[0])? Give it a
| try.

> x[0]
numeric(0)

| You are quite good my friend!

  |======================================                              |  56%
| As you might expect, we get nothing useful. Unfortunately, R doesn't
| prevent us from doing this. What if we ask for the 3000th element of x? Try
| it out.

> x[3000]
[1] NA

| That's the answer I was looking for.

  |========================================                            |  59%
| Again, nothing useful, but R doesn't prevent us from asking for it. This
| should be a cautionary tale. You should always make sure that what you are
| asking for is within the bounds of the vector you're working with.

...

  |==========================================                          |  62%
| What if we're interested in all elements of x EXCEPT the 2nd and 10th? It
| would be pretty tedious to construct a vector containing all numbers 1
| through 40 EXCEPT 2 and 10.

...

  |============================================                        |  64%
| Luckily, R accepts negative integer indexes. Whereas x[c(2, 10)] gives us
| ONLY the 2nd and 10th elements of x, x[c(-2, -10)] gives us all elements of
| x EXCEPT for the 2nd and 10 elements.  Try x[c(-2, -10)] now to see this.

> x[c(-2,-10)]
 [1] -0.8992949         NA  1.8747269         NA         NA         NA
 [7]         NA -0.5774856         NA         NA         NA  0.6115451
[13]         NA         NA  1.2041750  0.4961807         NA         NA
[19]  1.4390869         NA  1.0864976 -0.1112308         NA  0.2474371
[25] -0.5340157 -0.2403160         NA  2.0787604 -0.5161051  0.1654138
[31]  0.4712146         NA  0.2853485         NA         NA  0.1849741
[37]  0.2342391         NA

| You are doing so well!

  |=============================================                       |  67%
| A shorthand way of specifying multiple negative numbers is to put the
| negative sign out in front of the vector of positive numbers. Type x[-c(2,
| 10)] to get the exact same result.

> x[-c(2,10)]
 [1] -0.8992949         NA  1.8747269         NA         NA         NA
 [7]         NA -0.5774856         NA         NA         NA  0.6115451
[13]         NA         NA  1.2041750  0.4961807         NA         NA
[19]  1.4390869         NA  1.0864976 -0.1112308         NA  0.2474371
[25] -0.5340157 -0.2403160         NA  2.0787604 -0.5161051  0.1654138
[31]  0.4712146         NA  0.2853485         NA         NA  0.1849741
[37]  0.2342391         NA

| Perseverance, that's the answer.

  |===============================================                     |  69%
| So far, we've covered three types of index vectors -- logical, positive
| integer, and negative integer. The only remaining type requires us to
| introduce the concept of 'named' elements.

...

  |=================================================                   |  72%
| Create a numeric vector with three named elements using vect <- c(foo = 11,
| bar = 2, norf = NA).

> vect <- c(foo=11,bar = 2,norf = NA)

| You got it right!

  |===================================================                 |  74%
| When we print vect to the console, you'll see that each element has a name.
| Try it out.

> vect
 foo  bar norf 
  11    2   NA 

| Excellent job!

  |====================================================                |  77%
| We can also get the names of vect by passing vect as an argument to the
| names() function. Give that a try.

> names(vect)
[1] "foo"  "bar"  "norf"

| You are quite good my friend!

  |======================================================              |  79%
| Alternatively, we can create an unnamed vector vect2 with c(11, 2, NA). Do
| that now.

> vect2 <- c(11,2,NA)

| Perseverance, that's the answer.

  |========================================================            |  82%
| Then, we can add the `names` attribute to vect2 after the fact with
| names(vect2) <- c("foo", "bar", "norf"). Go ahead.

> names(vect2) <- c("foo","bar","norf")

| Excellent work!

  |==========================================================          |  85%
| Now, let's check that vect and vect2 are the same by passing them as
| arguments to the identical() function.

> identical(vect,vect2)
[1] TRUE

| Excellent job!

  |===========================================================         |  87%
| Indeed, vect and vect2 are identical named vectors.

...

  |=============================================================       |  90%
| Now, back to the matter of subsetting a vector by named elements. Which of
| the following commands do you think would give us the second element of
| vect?

1: vect[bar]
2: vect["bar"]
3: vect["2"]

Selection: 2

| Keep working like that and you'll get there!

  |===============================================================     |  92%
| Now, try it out.

> vect["bar"]
bar 
  2 

| Perseverance, that's the answer.

  |=================================================================   |  95%
| Likewise, we can specify a vector of names with vect[c("foo", "bar")]. Try
| it out.

> vect[c("foo","bar")]
foo bar 
 11   2 

| You are amazing!

  |==================================================================  |  97%
| Now you know all four methods of subsetting data from vectors. Different
| approaches are best in different scenarios and when in doubt, try it out!

...

  |====================================================================| 100%

### Matrixes and Dataframes

Selection: 7

  |                                                                    |   0%

| In this lesson, we'll cover matrices and data frames. Both represent
| 'rectangular' data types, meaning that they are used to store tabular data,
| with rows and columns.

...

  |==                                                                  |   3%
| The main difference, as you'll see, is that matrices can only contain a
| single class of data, while data frames can consist of many different
| classes of data.

...

  |====                                                                |   6%
| Let's create a vector containing the numbers 1 through 20 using the `:`
| operator. Store the result in a variable called my_vector.

> my_vector <- 1:20

| That's the answer I was looking for.

  |======                                                              |   8%
| View the contents of the vector you just created.

> my_vector
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| You nailed it! Good job!

  |========                                                            |  11%
| The dim() function tells us the 'dimensions' of an object. What happens if
| we do dim(my_vector)? Give it a try.

> dim(my_vector)
NULL

| You are quite good my friend!

  |=========                                                           |  14%
| Clearly, that's not very helpful! Since my_vector is a vector, it doesn't
| have a `dim` attribute (so it's just NULL), but we can find its length
| using the length() function. Try that now.

> length(my_vector)
[1] 20

| All that practice is paying off!

  |===========                                                         |  17%
| Ah! That's what we wanted. But, what happens if we give my_vector a `dim`
| attribute? Let's give it a try. Type dim(my_vector) <- c(4, 5).

> dim(my_vector) <- c(4, 5)

| Keep working like that and you'll get there!

  |=============                                                       |  19%
| It's okay if that last command seemed a little strange to you. It should!
| The dim() function allows you to get OR set the `dim` attribute for an R
| object. In this case, we assigned the value c(4, 5) to the `dim` attribute
| of my_vector.

...

  |===============                                                     |  22%
| Use dim(my_vector) to confirm that we've set the `dim` attribute correctly.

> dim(my_vector)
[1] 4 5

| That's the answer I was looking for.

  |=================                                                   |  25%
| Another way to see this is by calling the attributes() function on
| my_vector. Try it now.

> attributes(my_vector)
$dim
[1] 4 5


| Keep working like that and you'll get there!

  |===================                                                 |  28%
| Just like in math class, when dealing with a 2-dimensional object (think
| rectangular table), the first number is the number of rows and the second
| is the number of columns. Therefore, we just gave my_vector 4 rows and 5
| columns.

...

  |=====================                                               |  31%
| But, wait! That doesn't sound like a vector any more. Well, it's not. Now
| it's a matrix. View the contents of my_vector now to see what it looks
| like.

> my_vector
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20

| You got it!

  |=======================                                             |  33%
| Now, let's confirm it's actually a matrix by using the class() function.
| Type class(my_vector) to see what I mean.

> class(my_vector)
[1] "matrix" "array" 

| That's the answer I was looking for.

  |=========================                                           |  36%
| Sure enough, my_vector is now a matrix. We should store it in a new
| variable that helps us remember what it is. Store the value of my_vector in
| a new variable called my_matrix.

> my_matrix <- my_vector

| You got it right!

  |==========================                                          |  39%
| The example that we've used so far was meant to illustrate the point that a
| matrix is simply an atomic vector with a dimension attribute. A more direct
| method of creating the same matrix uses the matrix() function.

...

  |============================                                        |  42%
| Bring up the help file for the matrix() function now using the `?`
| function.

> ?matrix()

| Not quite right, but keep trying. Or, type info() for more options.

| The command ?matrix will do the trick.

> ?matrix

| Excellent work!

  |==============================                                      |  44%
| Now, look at the documentation for the matrix function and see if you can
| figure out how to create a matrix containing the same numbers (1-20) and
| dimensions (4 rows, 5 columns) by calling the matrix() function. Store the
| result in a variable called my_matrix2.

> my_matrix2 <- (1:20,nrow = 4,ncol = 5)
Error: unexpected ',' in "my_matrix2 <- (1:20,"
> my_matrix2 <- (data=1:20,nrow = 4,ncol = 5)
Error: unexpected ',' in "my_matrix2 <- (data=1:20,"
> my_matrix2 <- (data=c(1:20),nrow = 4,ncol = 5)
Error: unexpected ',' in "my_matrix2 <- (data=c(1:20),"
> num <- 1:20

| Almost! Try again. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of
| rows, and the number of columns. Be sure to specify arguments by their
| proper names and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(data =1:20,nrow =4,ncol=5)

| Great job!

  |================================                                    |  47%
| Finally, let's confirm that my_matrix and my_matrix2 are actually
| identical. The identical() function will tell us if its first two arguments
| are the same. Try it out.

> identical(my_matrix,my_matrix2)
[1] TRUE

| You are quite good my friend!

  |==================================                                  |  50%
| Now, imagine that the numbers in our table represent some measurements from
| a clinical experiment, where each row represents one patient and each
| column represents one variable for which measurements were taken.

...

  |====================================                                |  53%
| We may want to label the rows, so that we know which numbers belong to each
| patient in the experiment. One way to do this is to add a column to the
| matrix, which contains the names of all four people.

...

  |======================================                              |  56%
| Let's start by creating a character vector containing the names of our
| patients -- Bill, Gina, Kelly, and Sean. Remember that double quotes tell R
| that something is a character string. Store the result in a variable called
| patients.

> patients <- c("Bill","Gina","Kelly","Sean")

| You are really on a roll!

  |========================================                            |  58%
| Now we'll use the cbind() function to 'combine columns'. Don't worry about
| storing the result in a new variable. Just call cbind() with two arguments
| -- the patients vector and my_matrix.

> c_bind(patients,my)
Error in c_bind(patients, my) : could not find function "c_bind"
> c_bind(patients,my_matrix)
Error in c_bind(patients, my_matrix) : could not find function "c_bind"
> cbind(patients,my_matrix)
     patients                       
[1,] "Bill"   "1" "5" "9"  "13" "17"
[2,] "Gina"   "2" "6" "10" "14" "18"
[3,] "Kelly"  "3" "7" "11" "15" "19"
[4,] "Sean"   "4" "8" "12" "16" "20"

| All that practice is paying off!

  |==========================================                          |  61%
| Something is fishy about our result! It appears that combining the
| character vector with our matrix of numbers caused everything to be
| enclosed in double quotes. This means we're left with a matrix of character
| strings, which is no good.

...

  |===========================================                         |  64%
| If you remember back to the beginning of this lesson, I told you that
| matrices can only contain ONE class of data. Therefore, when we tried to
| combine a character vector with a numeric matrix, R was forced to 'coerce'
| the numbers to characters, hence the double quotes.

...

  |=============================================                       |  67%
| This is called 'implicit coercion', because we didn't ask for it. It just
| happened. But why didn't R just convert the names of our patients to
| numbers? I'll let you ponder that question on your own.

...

  |===============================================                     |  69%
| So, we're still left with the question of how to include the names of our
| patients in the table without destroying the integrity of our numeric data.
| Try the following -- my_data <- data.frame(patients, my_matrix)

> my_data <- data.frame(patients,my_matrix)

| Your dedication is inspiring!

  |=================================================                   |  72%
| Now view the contents of my_data to see what we've come up with.

> my_data
  patients X1 X2 X3 X4 X5
1     Bill  1  5  9 13 17
2     Gina  2  6 10 14 18
3    Kelly  3  7 11 15 19
4     Sean  4  8 12 16 20

| Keep up the great work!

  |===================================================                 |  75%
| It looks like the data.frame() function allowed us to store our character
| vector of names right alongside our matrix of numbers. That's exactly what
| we were hoping for!

...

  |=====================================================               |  78%
| Behind the scenes, the data.frame() function takes any number of arguments
| and returns a single object of class `data.frame` that is composed of the
| original objects.

...

  |=======================================================             |  81%
| Let's confirm this by calling the class() function on our newly created
| data frame.

> class(my_data)
[1] "data.frame"

| Excellent job!

  |=========================================================           |  83%
| It's also possible to assign names to the individual rows and columns of a
| data frame, which presents another possible way of determining which row of
| values in our table belongs to each patient.

...

  |===========================================================         |  86%
| However, since we've already solved that problem, let's solve a different
| problem by assigning names to the columns of our data frame so that we know
| what type of measurement each column represents.

...

  |============================================================        |  89%
| Since we have six columns (including patient names), we'll need to first
| create a vector containing one element for each column. Create a character
| vector called cnames that contains the following values (in order) --
| "patient", "age", "weight", "bp", "rating", "test".

> cnames <- c("patient","age","weight","bp","rating","test")

| All that hard work is paying off!

  |==============================================================      |  92%
| Now, use the colnames() function to set the `colnames` attribute for our
| data frame. This is similar to the way we used the dim() function earlier
| in this lesson.

> my_data <- colnames(cnames)

| Keep trying! Or, type info() for more options.

| Try colnames(my_data) <- cnames.

> colnames(my_data) <- cnames

| You are really on a roll!

  |================================================================    |  94%
| Let's see if that got the job done. Print the contents of my_data.

> my_data
  patient age weight bp rating test
1    Bill   1      5  9     13   17
2    Gina   2      6 10     14   18
3   Kelly   3      7 11     15   19
4    Sean   4      8 12     16   20

| You got it right!

  |==================================================================  |  97%
| In this lesson, you learned the basics of working with two very important
| and common data structures -- matrices and data frames. There's much more
| to learn and we'll be covering more advanced topics, particularly with
| respect to data frames, in future lessons.

...

  |====================================================================| 100%